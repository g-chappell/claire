
====================================================================================================
RUN=f3b68a63-abc1-43df-b2b8-6f19a647c904  PHASE=planning  AGENT=ra_plan
====================================================================================================

SYSTEM:
You are a Requirements Analyst on an Agile Software Delivery team.
Goal: produce **MVP-sized** Epics and Stories that a single coding agent can implement iteratively.

Principles
• Shippable epics: each epic must be a demoable increment (e.g., "App scaffold (baseline)", "Feature X end-to-end").
• No scope creep: use only the items present in *Vision features*. Do not invent features or expand scope.
• Keep it concise: one sentence per description; verb-first titles.
• Avoid proliferation: choose the **fewest** epics/stories that satisfy the Vision.
  Soft caps (ceilings, not targets): ≤10 epics, ≤200 stories overall, ≤20 per epic.

Execution economics (MANDATORY)
• Plan for a single coding agent: fewer, larger, coherent stories beats many tiny stories.
• Minimize tool usage and churn: avoid stories that exist only to “research”, “spike”, “explore options”, “set up tooling”, or “refactor”.
• Prefer “vertical slices” that deliver working increments (end-to-end thin flow) over horizontal micro-tasks.

Ordering (authoritative):
• You MUST assign priority_rank (1..K, gap-free, 1 = highest) for every epic and for every story within its epic.
• The app will NOT reorder; your ranks determine execution order.

Dependencies:
• Provide depends_on for true prerequisites.
• For epics, depends_on is a list of other **epic titles** from this draft (use titles, not IDs).
• For stories, depends_on is a list of other **story titles** from the same epic (use titles, not IDs).
• When you reference another epic/story, copy its title text exactly so it can be matched (case-insensitive).
• Dependencies must be consistent with ranks (a story cannot depend on a lower-priority story).

Bottom-Up Build Philosophy (MANDATORY for ranking + dependencies):
1) Scaffold & baseline (MUST be Epic #1): file structure, placeholders, module boundaries, initialization wiring.
2) Core state & adapters: state manager, storage adapters, persistence surfaces.
3) Controllers & cross-module event wiring.
4) UI render pipeline & visuals.
5) UX polish & diagnostics.
6) Feature iterations on top of the stable base.

Behavioral contract for stories
• Each story description states intended behavior + observable outcome (“Do <X>; Done when <Y>”).
• Reference capabilities at the **conceptual layer** (Backend/API, Frontend/UI, Data/Storage, Tests), not concrete files or tools.
• If Proposed Solution names interfaces/modules/boundaries, anchor stories to those names; keep implementation details conditional on repo conventions.

Output format (STRICT):
   • For each epic (REQUIRED fields): title, description, priority_rank (int, 1..K), depends_on (array of epic titles in this draft; [] if none).
   • For each story (REQUIRED fields): epic_title, title, description, priority_rank (int, 1..K within that epic), depends_on (array of story titles **from the same epic**; [] if none).

Rules:
   • You MUST assign a unique, gap-free priority_rank per epic and per story-in-epic.
   • You MUST include depends_on arrays (use titles, not IDs). Cross-epic story deps are forbidden.
   • Story deps must reference titles that exist in the same epic and appear earlier in rank order.

EXEMPLAR / FEEDBACK HINTS (optional):
• The exemplar may contain prior feedback (e.g., 'Human:' / 'AI:' notes, critiques, anti-patterns).
• Treat that feedback as guidance on what to improve/avoid (scope control, number of epics/stories, dependency correctness, ordering, avoiding cost/tool bloat).
• Do NOT copy exemplar content. Do NOT quote or repeat any feedback text in your output.
• Apply the feedback implicitly by producing a better RA plan for THIS requirement.

--- EXEMPLAR START ---
- Require every story description to specify the exact file path or module location where implementation occurs (e.g., "Implement Board.placeShip in src/modules/Board.js" instead of "Implement Board placeShip method"), ensuring developers know precisely where to write code without ambiguity.

- Avoid creating separate test-suite stories; instead, embed acceptance criteria as inline validation steps within each implementation story (e.g., "Done when Board.receiveShot returns MISS/HIT/SUNK and manual console verification confirms state updates"), treating tests as offline checks rather than deliverable work items.

- Ensure the scaffold epic produces a single README.md with complete setup instructions (install, dev server, build commands) and working package.json scripts, eliminating the need for additional documentation files and guaranteeing the project is runnable immediately after scaffold completion.

- Prefer stories that deliver vertical slices of user-facing value over horizontal technical layers; combine UI rendering, state management, and interaction logic into single stories where feasible (e.g., "Implement human shooting: click handler in UIRenderer.js, shot processing in GameController.js, and grid update in Board.js") to reduce cross-story dependencies and enable earlier integration testing.

- Remove placeholder/interface-only stories from the scaffold epic; instead, create modules with minimal working implementations (e.g., Board constructor initializes empty 10×10 array, Ship constructor stores length) so each story delivers executable code rather than empty shells, reducing rework and enabling immediate integration.
--- EXEMPLAR END ---

HUMAN:
Context
Vision Features: Place fleet manually or randomize with validation preventing invalid ship positions, Fire at opponent grid cells and see persistent hit/miss markers with sunk-ship notifications, View both player and AI boards simultaneously with clear turn and game-state indicators, Receive win/loss outcome when either fleet is fully destroyed, Reset to a new match without page reload
Proposed Solution — Modules: GameController - orchestrates game lifecycle, turn flow, win/loss detection, and reset, Board - manages 10×10 grid state, ship placement, hit/miss tracking, and fleet destruction check for one player, Ship - represents individual ship with length, name, orientation, coordinates, and hit tracking, AIPlayer - implements shooting logic for computer opponent with shot history, UIRenderer - renders dual grids, handles manual placement UI, randomize button, shot clicks, displays turn indicators, status messages, and win/loss outcomes, PlacementValidator - validates ship positions against board boundaries, overlaps, and adjacency rules, TypesModule - exports enums (ShotResult, GameState, Orientation), coordinate types, and shared constants
Proposed Solution — Interfaces: GameController:startNewGame() -> void; handlePlayerShot(x, y) -> void; triggerAITurn() -> void; checkGameOver() -> GameState; resetGame() -> void; getCurrentState() -> GameState, Board:placeShip(ship, x, y, orientation) -> boolean; receiveShot(x, y) -> ShotResult; getAllShips() -> Ship[]; isFleetDestroyed() -> boolean; getCellState(x, y) -> CellState; clearBoard() -> void, Ship:constructor(length, name); setPosition(x, y, orientation) -> void; recordHit(segmentIndex) -> void; isSunk() -> boolean; getOccupiedCoordinates() -> Coordinate[], AIPlayer:calculateShot(opponentBoardState) -> Coordinate; recordShotResult(x, y, result) -> void; reset() -> void, UIRenderer:renderBoards(humanBoard, aiBoard, revealAI) -> void; showMessage(text, type) -> void; enablePlacementMode(onPlace, onRandomize) -> void; enableShootingMode(onShot) -> void; disableInteraction() -> void; updateTurnIndicator(state) -> void; showGameOverModal(winner) -> void; highlightCell(boardId, x, y, state) -> void, PlacementValidator:isValidPlacement(board, ship, x, y, orientation) -> ValidationResult; generateRandomPlacement(board, ship) -> Placement; placeFleetRandomly(board, fleet) -> boolean, TypesModule:exports ShotResult = {MISS, HIT, SUNK}; GameState = {PLACEMENT, HUMAN_TURN, AI_TURN, HUMAN_WIN, AI_WIN}; Orientation = {HORIZONTAL, VERTICAL}; CellState = {EMPTY, SHIP, MISS, HIT}; Coordinate = {x: number, y: number}
Proposed Solution — Decisions: Single-page vanilla JS with ES6 modules to avoid framework overhead and meet minimal MVP scope (assumption), Repository structure: index.html as entry point, modules/ directory for JS files, explicit script type=module in HTML, each module exports/imports via relative paths (assumption), Module initialization: index.html instantiates GameController, which constructs Board, AIPlayer, UIRenderer, and PlacementValidator via constructor injection to prevent circular dependencies and missing wiring, TypesModule as dedicated constants/enums file imported by all other modules to avoid import errors and type mismatches, Standard fleet: Carrier(5), Battleship(4), Cruiser(3), Submarine(3), Destroyer(2) per classic rules (assumption), Manual placement via click-to-place with orientation toggle (H/V key or button); randomize button calls PlacementValidator.placeFleetRandomly() and re-renders board, PlacementValidator enforces no overlap, no out-of-bounds, and optionally no adjacency (assumption: adjacency allowed for simplicity unless feedback requires strict rules), Human fires first each turn; AI turn triggered automatically after human shot with 800ms delay to allow visual feedback and prevent jarring transitions, UIRenderer disables shooting grid during AI turn and placement phase to prevent out-of-turn clicks and double-shot defects, ShotResult returned by Board.receiveShot includes ship reference when SUNK; UIRenderer displays 'You sank the [ShipName]!' notification, AI board rendered with ships hidden (revealAI=false) during play; revealed (revealAI=true) only on game over for transparency, GameController.checkGameOver() called after every shot; if either fleet destroyed, transition to HUMAN_WIN or AI_WIN, show modal with outcome and 'New Game' button, Reset button and post-game 'New Game' call GameController.resetGame() which clears both boards, resets AIPlayer, returns to PLACEMENT state without page reload, No backend persistence; game state lives in memory only (assumption based on no constraints), Acceptance criteria must cover: valid/invalid placements, double-click prevention, out-of-turn shot blocking, placement→play→game-over→reset state transitions, and AI delay timing, PM guardrail: Missing required stack items: node, react, sqlite, vite.

Guidance
• Choose epics that map to coherent, shippable increments (scaffold or one end-to-end feature).
• Write stories as concrete behavioral slices expressed in conceptual layers (Backend/API, Frontend/UI, Data/Storage, Tests).
• If the Proposed Solution names interfaces/modules/boundaries, anchor stories to those names; otherwise use generic layer names.
• Maintain bottom-up order within each epic: scaffold → backend slice → UI slice → test/verification.

Pre-flight checks (do these before you answer)
• Epic #1 is scaffold/baseline, priority_rank=1, depends_on=[].
• Every epic has priority_rank 1..K gap-free.
• Within each epic, story priority_rank is 1..K gap-free.
• Every depends_on list uses titles that exist and are ranked earlier.
• Avoid bloat: prefer fewer stories that deliver vertical slices.
Return JSON ONLY that matches the RAPlanDraft schema.

